<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Chat - SigmaWeb</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f23;
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: #171717;
            border-right: 1px solid #2a2a2a;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #2a2a2a;
        }

        .new-chat-btn {
            width: 100%;
            padding: 12px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        .new-chat-btn:hover {
            background: #1d4ed8;
        }

        .new-chat-btn:disabled {
            background: #4a4a4a;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .chat-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .chat-item {
            padding: 12px;
            margin: 4px 0;
            background: #2a2a2a;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        .chat-item:hover {
            background: #3a3a3a;
        }

        .chat-item.active {
            background: #2563eb;
        }

        .chat-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 14px;
        }

        .delete-chat {
            background: #dc2626;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 8px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .chat-item:hover .delete-chat {
            opacity: 1;
        }

        .delete-chat:hover {
            background: #b91c1c;
        }

        /* Main Chat Area */
        .main-chat {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0f0f23;
        }

        .chat-header {
            padding: 20px;
            border-bottom: 1px solid #2a2a2a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .model-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .model-select {
            padding: 8px 12px;
            background: #2a2a2a;
            color: white;
            border: 1px solid #4a4a4a;
            border-radius: 6px;
            outline: none;
        }

        .usage-info {
            font-size: 14px;
            color: #888;
        }

        .usage-info.warning {
            color: #f59e0b;
        }

        .usage-info.limit-reached {
            color: #dc2626;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .message {
            display: flex;
            gap: 12px;
            max-width: 800px;
            margin: 0 auto;
            width: 100%;
        }

        .message.user {
            flex-direction: row-reverse;
        }

        .avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            flex-shrink: 0;
        }

        .user-avatar {
            background: #2563eb;
        }

        .ai-avatar {
            background: #059669;
        }

        .message-content {
            background: #2a2a2a;
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 70%;
            word-wrap: break-word;
            position: relative;
        }

        .message.user .message-content {
            background: #2563eb;
            margin-left: auto;
        }

        .timestamp {
            font-size: 12px;
            color: #888;
            margin-top: 4px;
        }

        .code-block {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            margin: 8px 0;
            overflow: hidden;
        }

        .code-header {
            background: #2a2a2a;
            padding: 8px 12px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .code-language {
            color: #888;
            font-weight: 500;
        }

        .copy-btn {
            background: #4a4a4a;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .copy-btn:hover {
            background: #5a5a5a;
        }

        .copy-btn.copied {
            background: #059669;
        }

        .code-content {
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
            white-space: pre-wrap;
        }

        /* Input Area */
        .input-area {
            padding: 20px;
            border-top: 1px solid #2a2a2a;
        }

        .input-container {
            max-width: 800px;
            margin: 0 auto;
            position: relative;
        }

        .message-input {
            width: 100%;
            padding: 12px 50px 12px 16px;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 12px;
            color: white;
            outline: none;
            font-size: 16px;
            min-height: 48px;
            max-height: 120px;
            resize: none;
        }

        .message-input:focus {
            border-color: #2563eb;
        }

        .message-input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .send-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: #2563eb;
            color: white;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .send-btn:hover {
            background: #1d4ed8;
        }

        .send-btn:disabled {
            background: #4a4a4a;
            cursor: not-allowed;
        }

        .char-count {
            font-size: 12px;
            color: #888;
            text-align: right;
            margin-top: 4px;
        }

        .char-count.warning {
            color: #f59e0b;
        }

        .char-count.error {
            color: #dc2626;
        }

        /* Welcome Screen */
        .welcome {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            padding: 40px;
        }

        .welcome h1 {
            font-size: 48px;
            margin-bottom: 16px;
            background: linear-gradient(135deg, #2563eb, #059669, #7c3aed);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                filter: drop-shadow(0 0 10px rgba(37, 99, 235, 0.5));
            }
            to {
                filter: drop-shadow(0 0 20px rgba(5, 150, 105, 0.8));
            }
        }

        .welcome p {
            color: #888;
            font-size: 18px;
            margin-bottom: 32px;
        }

        .start-chat-btn {
            padding: 16px 32px;
            background: linear-gradient(135deg, #2563eb, #059669);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .start-chat-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(37, 99, 235, 0.3);
        }

        .loading {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #888;
            font-style: italic;
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #444;
            border-top: 2px solid #059669;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #171717;
        }

        ::-webkit-scrollbar-thumb {
            background: #4a4a4a;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #5a5a5a;
        }

        .company-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #666;
            font-size: 12px;
        }

        @media (max-width: 768px) {
            .sidebar {
                display: none;
            }
            
            .welcome h1 {
                font-size: 36px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <button class="new-chat-btn" onclick="createNewChat()" id="newChatBtn">+ New Chat</button>
            </div>
            <div class="chat-list" id="chatList">
                <!-- Chat items will be populated here -->
            </div>
        </div>

        <!-- Main Chat Area -->
        <div class="main-chat">
            <div class="chat-header" id="chatHeader" style="display: none;">
                <div class="model-selector">
                    <label for="modelSelect">Model:</label>
                    <select class="model-select" id="modelSelect" onchange="handleModelChange()">
                        <option value="haiku-3">Claude Haiku 3</option>
                        <option value="haiku-3.5">Claude Haiku 3.5</option>
                        <option value="sonnet-3.5">Claude Sonnet 3.5</option>
                    </select>
                </div>
                <div class="usage-info" id="usageInfo">
                    Messages today: 0/20
                </div>
            </div>

            <!-- Welcome Screen -->
            <div id="welcomeScreen" class="welcome">
                <h1>Claude AI</h1>
                <p>Welcome to Claude Chat! Powered by Anthropic's advanced AI</p>
                <button class="start-chat-btn" onclick="createNewChat()">Start New Chat</button>
                <div class="company-info">Built by SigmaWeb</div>
            </div>

            <div class="chat-messages" id="chatMessages" style="display: none;">
                <!-- Messages will be populated here -->
            </div>

            <!-- Input Area -->
            <div class="input-area" id="inputArea" style="display: none;">
                <div class="input-container">
                    <textarea 
                        class="message-input" 
                        id="messageInput" 
                        placeholder="Message Claude..."
                        onkeydown="handleKeyDown(event)"
                        oninput="updateCharCount()"
                    ></textarea>
                    <button class="send-btn" id="sendBtn" onclick="sendMessage()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                        </svg>
                    </button>
                    <div class="char-count" id="charCount">0/1000</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =============== CONFIGURATION ===============
        const CONFIG = {
            MAX_MESSAGE_LENGTH: 1000,
            DAILY_LIMITS: {
                'haiku-3': 20,
                'haiku-3.5': 15,
                'sonnet-3.5': 5
            },
            // REPLACE WITH YOUR ACTUAL API KEY
            API_KEY: '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',
            API_ENDPOINT: 'https://api.anthropic.com/v1/messages',
            MODEL_MAPPING: {
                'haiku-3': 'claude-3-haiku-20240307',
                'haiku-3.5': 'claude-3-5-haiku-20241022', 
                'sonnet-3.5': 'claude-3-5-sonnet-20241022'
            },
            MAX_BLANK_CHATS: 1
        };

        // =============== STATE MANAGEMENT ===============
        let currentChatId = null;
        let chats = {};
        let dailyUsage = {};
        let isProcessing = false;
        let processingChatId = null;

        // =============== INITIALIZATION ===============
        document.addEventListener('DOMContentLoaded', function() {
            loadFromStorage();
            updateUI();
            resetDailyUsageIfNeeded();
        });

        function loadFromStorage() {
            try {
                // Load chats
                const storedChats = JSON.parse(localStorage.getItem('claudeChats') || '{}');
                chats = storedChats;

                // Load daily usage
                const storedUsage = JSON.parse(localStorage.getItem('claudeDailyUsage') || '{}');
                dailyUsage = storedUsage;
            } catch (error) {
                console.error('Error loading from storage:', error);
                chats = {};
                dailyUsage = {};
            }
        }

        function saveToStorage() {
            try {
                localStorage.setItem('claudeChats', JSON.stringify(chats));
                localStorage.setItem('claudeDailyUsage', JSON.stringify(dailyUsage));
            } catch (error) {
                console.error('Error saving to storage:', error);
            }
        }

        function resetDailyUsageIfNeeded() {
            const today = new Date().toDateString();
            const lastResetDate = localStorage.getItem('lastResetDate');
            
            if (lastResetDate !== today) {
                dailyUsage = {
                    'haiku-3': 0,
                    'haiku-3.5': 0,
                    'sonnet-3.5': 0,
                    date: today
                };
                localStorage.setItem('lastResetDate', today);
                saveToStorage();
            }
        }

        // =============== CHAT MANAGEMENT ===============
        function createNewChat() {
            // Check if there's already a blank chat
            const blankChats = Object.values(chats).filter(chat => chat.messages.length === 0);
            if (blankChats.length >= CONFIG.MAX_BLANK_CHATS) {
                // Select the existing blank chat instead of creating a new one
                currentChatId = blankChats[0].id;
                updateUI();
                showChatInterface();
                return;
            }

            const chatId = 'chat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const chatTitle = `New Chat`;
            
            chats[chatId] = {
                id: chatId,
                title: chatTitle,
                messages: [],
                createdAt: Date.now(),
                model: 'haiku-3'
            };
            
            currentChatId = chatId;
            saveToStorage();
            updateUI();
            showChatInterface();
        }

        function selectChat(chatId) {
            if (isProcessing && processingChatId !== chatId) {
                // Don't allow switching chats while processing
                return;
            }
            
            currentChatId = chatId;
            updateUI();
            showChatInterface();
        }

        function deleteChat(chatId, event) {
            event.stopPropagation();
            
            if (isProcessing && processingChatId === chatId) {
                alert('Cannot delete chat while processing message');
                return;
            }
            
            if (confirm('Are you sure you want to delete this chat?')) {
                delete chats[chatId];
                
                if (currentChatId === chatId) {
                    currentChatId = null;
                    showWelcomeScreen();
                }
                
                saveToStorage();
                updateUI();
            }
        }

        function generateChatTitle(userMessage) {
            // Generate a title from the first user message
            const words = userMessage.split(' ');
            const title = words.slice(0, 6).join(' ');
            return title.length > 30 ? title.substring(0, 30) + '...' : title;
        }

        // =============== UI UPDATES ===============
        function updateUI() {
            updateChatList();
            updateUsageInfo();
            updateChatMessages();
            updateNewChatButton();
        }

        function updateChatList() {
            const chatList = document.getElementById('chatList');
            chatList.innerHTML = '';
            
            const sortedChats = Object.values(chats).sort((a, b) => b.createdAt - a.createdAt);
            
            sortedChats.forEach(chat => {
                const chatItem = document.createElement('div');
                chatItem.className = `chat-item ${chat.id === currentChatId ? 'active' : ''}`;
                chatItem.onclick = () => selectChat(chat.id);
                
                // Show processing indicator if this chat is being processed
                const processingIndicator = isProcessing && processingChatId === chat.id ? ' •' : '';
                
                chatItem.innerHTML = `
                    <div class="chat-title">${chat.title}${processingIndicator}</div>
                    <button class="delete-chat" onclick="deleteChat('${chat.id}', event)">×</button>
                `;
                
                chatList.appendChild(chatItem);
            });
        }

        function updateNewChatButton() {
            const newChatBtn = document.getElementById('newChatBtn');
            const blankChats = Object.values(chats).filter(chat => chat.messages.length === 0);
            
            if (blankChats.length >= CONFIG.MAX_BLANK_CHATS) {
                newChatBtn.disabled = true;
                newChatBtn.textContent = 'Complete Current Chat';
            } else {
                newChatBtn.disabled = false;
                newChatBtn.textContent = '+ New Chat';
            }
        }

        function updateUsageInfo() {
            const currentModel = document.getElementById('modelSelect').value;
            const used = dailyUsage[currentModel] || 0;
            const limit = CONFIG.DAILY_LIMITS[currentModel];
            const usageInfo = document.getElementById('usageInfo');
            
            usageInfo.textContent = `Messages today: ${used}/${limit}`;
            
            // Update styling based on usage
            usageInfo.className = 'usage-info';
            if (used >= limit) {
                usageInfo.className += ' limit-reached';
            } else if (used >= limit * 0.8) {
                usageInfo.className += ' warning';
            }
        }

        function updateChatMessages() {
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '';
            
            if (!currentChatId || !chats[currentChatId]) {
                return;
            }
            
            const messages = chats[currentChatId].messages;
            messages.forEach(message => {
                const messageDiv = createMessageElement(message);
                chatMessages.appendChild(messageDiv);
            });
            
            // Auto-scroll to bottom
            setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }, 100);
        }

        function createMessageElement(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${message.role}`;
            
            const timestamp = new Date(message.timestamp).toLocaleTimeString();
            const content = processMessageContent(message.content);
            
            messageDiv.innerHTML = `
                <div class="avatar ${message.role}-avatar">
                    ${message.role === 'user' ? 'U' : 'C'}
                </div>
                <div class="message-content">
                    ${content}
                    <div class="timestamp">${timestamp}</div>
                </div>
            `;
            
            return messageDiv;
        }

        function processMessageContent(content) {
            // Process code blocks
            const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
            return content.replace(codeBlockRegex, (match, language, code) => {
                const lang = language || 'text';
                const codeId = 'code_' + Math.random().toString(36).substr(2, 9);
                
                return `
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-language">${lang.toUpperCase()}</span>
                            <button class="copy-btn" onclick="copyCode('${codeId}')">Copy</button>
                        </div>
                        <div class="code-content" id="${codeId}">${escapeHtml(code.trim())}</div>
                    </div>
                `;
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function copyCode(codeId) {
            const codeElement = document.getElementById(codeId);
            const copyBtn = codeElement.parentElement.querySelector('.copy-btn');
            
            navigator.clipboard.writeText(codeElement.textContent).then(() => {
                copyBtn.textContent = 'Copied!';
                copyBtn.classList.add('copied');
                setTimeout(() => {
                    copyBtn.textContent = 'Copy';
                    copyBtn.classList.remove('copied');
                }, 2000);
            });
        }

        function showWelcomeScreen() {
            document.getElementById('welcomeScreen').style.display = 'flex';
            document.getElementById('chatMessages').style.display = 'none';
            document.getElementById('inputArea').style.display = 'none';
            document.getElementById('chatHeader').style.display = 'none';
        }

        function showChatInterface() {
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('chatMessages').style.display = 'flex';
            document.getElementById('inputArea').style.display = 'block';
            document.getElementById('chatHeader').style.display = 'flex';
        }

        function showLoadingMessage() {
            if (!currentChatId || !chats[currentChatId]) return;
            
            const chatMessages = document.getElementById('chatMessages');
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'message assistant';
            loadingDiv.id = 'loading-message';
            
            loadingDiv.innerHTML = `
                <div class="avatar ai-avatar">C</div>
                <div class="message-content">
                    <div class="loading">
                        <div class="spinner"></div>
                        Thinking...
                    </div>
                </div>
            `;
            
            chatMessages.appendChild(loadingDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function removeLoadingMessage() {
            const loadingMessage = document.getElementById('loading-message');
            if (loadingMessage) {
                loadingMessage.remove();
            }
        }

        // =============== MESSAGE HANDLING ===============
        function handleKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        function updateCharCount() {
            const input = document.getElementById('messageInput');
            const charCount = document.getElementById('charCount');
            const length = input.value.length;
            
            charCount.textContent = `${length}/${CONFIG.MAX_MESSAGE_LENGTH}`;
            
            if (length > CONFIG.MAX_MESSAGE_LENGTH * 0.9) {
                charCount.className = 'char-count warning';
            } else if (length >= CONFIG.MAX_MESSAGE_LENGTH) {
                charCount.className = 'char-count error';
            } else {
                charCount.className = 'char-count';
            }
            
            const sendBtn = document.getElementById('sendBtn');
            const input_elem = document.getElementById('messageInput');
            const canSend = length > 0 && length <= CONFIG.MAX_MESSAGE_LENGTH && !isProcessing;
            
            sendBtn.disabled = !canSend;
            input_elem.disabled = isProcessing;
        }

        function handleModelChange() {
            if (currentChatId && chats[currentChatId]) {
                chats[currentChatId].model = document.getElementById('modelSelect').value;
                saveToStorage();
            }
            updateUsageInfo();
        }

        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message || message.length > CONFIG.MAX_MESSAGE_LENGTH || isProcessing) {
                return;
            }
            
            if (!currentChatId) {
                createNewChat();
            }
            
            const currentModel = document.getElementById('modelSelect').value;
            const used = dailyUsage[currentModel] || 0;
            const limit = CONFIG.DAILY_LIMITS[currentModel];
            
            if (used >= limit) {
                alert(`Daily limit reached for ${currentModel}. Please try again tomorrow or switch to another model.`);
                return;
            }
            
            // Set processing state
            isProcessing = true;
            processingChatId = currentChatId;
            
            // Add user message
            const userMessage = {
                role: 'user',
                content: message,
                timestamp: Date.now()
            };
            
            chats[currentChatId].messages.push(userMessage);
            
            // Update chat title if this is the first message
            if (chats[currentChatId].messages.length === 1) {
                chats[currentChatId].title = generateChatTitle(message);
            }
            
            // Update daily usage
            dailyUsage[currentModel] = (dailyUsage[currentModel] || 0) + 1;
            
            // Clear input and update UI
            input.value = '';
            updateCharCount();
            saveToStorage();
            updateUI();
            
            // Show loading message
            showLoadingMessage();
            
            try {
                // Send request to Claude API
                await sendToClaudeAPI();
            } catch (error) {
                console.error('Error calling Claude API:', error);
                // Add error message
                const errorMessage = {
                    role: 'assistant',
                    content: 'Sorry, I encountered an error while processing your message. Please check your API key and try again.',
                    timestamp: Date.now()
                };
                chats[currentChatId].messages.push(errorMessage);
            } finally {
                // Clear processing state
                isProcessing = false;
                processingChatId = null;
                removeLoadingMessage();
                saveToStorage();
                updateUI();
            }
        }

        async function sendToClaudeAPI() {
            if (!CONFIG.API_KEY || CONFIG.API_KEY === 'sk-ant-api03-your-api-key-here') {
                throw new Error('API key not configured');
            }
            
            const currentModel = document.getElementById('modelSelect').value;
            const modelName = CONFIG.MODEL_MAPPING[currentModel];
            
            // Format messages for Claude API
            const apiMessages = chats[currentChatId].messages.map(msg => ({
                role: msg.role === 'assistant' ? 'assistant' : 'user',
                content: msg.content
            }));

            const requestBody = {
                model: modelName,
                max_tokens: 1024,
                messages: apiMessages
            };

            const response = await fetch(CONFIG.API_ENDPOINT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': CONFIG.API_KEY,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`API request failed: ${response.status} ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);
            }

            const data = await response.json();
            
            if (data.content && data.content.length > 0) {
                const assistantMessage = {
                    role: 'assistant',
                    content: data.content[0].text,
                    timestamp: Date.now()
                };
                chats[currentChatId].messages.push(assistantMessage);
            } else {
                throw new Error('Invalid response format from API');
            }
        }

        // =============== BUG FIXES & IMPROVEMENTS ===============
        
        // Fix 1: Prevent race conditions in chat switching
        function preventRaceCondition() {
            if (isProcessing) {
                const allChatItems = document.querySelectorAll('.chat-item');
                allChatItems.forEach(item => {
                    if (!item.classList.contains('active')) {
                        item.style.pointerEvents = 'none';
                        item.style.opacity = '0.5';
                    }
                });
            } else {
                const allChatItems = document.querySelectorAll('.chat-item');
                allChatItems.forEach(item => {
                    item.style.pointerEvents = 'auto';
                    item.style.opacity = '1';
                });
            }
        }

        // Fix 2: Ensure proper cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (isProcessing) {
                isProcessing = false;
                processingChatId = null;
                removeLoadingMessage();
            }
        });

        // Fix 3: Prevent duplicate message sending
        let lastMessageTime = 0;
        function preventDuplicateMessages() {
            const now = Date.now();
            if (now - lastMessageTime < 1000) { // 1 second cooldown
                return false;
            }
            lastMessageTime = now;
            return true;
        }

        // Fix 4: Handle storage quota exceeded
        function safeStorageOperation(operation) {
            try {
                operation();
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    // Remove oldest chats if storage is full
                    const chatIds = Object.keys(chats).sort((a, b) => 
                        chats[a].createdAt - chats[b].createdAt
                    );
                    
                    // Remove oldest 25% of chats
                    const toRemove = Math.ceil(chatIds.length * 0.25);
                    for (let i = 0; i < toRemove; i++) {
                        delete chats[chatIds[i]];
                    }
                    
                    try {
                        operation(); // Retry operation
                    } catch (retryError) {
                        console.error('Storage operation failed even after cleanup:', retryError);
                    }
                } else {
                    console.error('Storage operation failed:', error);
                }
            }
        }

        // Fix 5: Debounce UI updates
        let updateUITimeout;
        function debouncedUpdateUI() {
            clearTimeout(updateUITimeout);
            updateUITimeout = setTimeout(updateUI, 100);
        }

        // Fix 6: Validate chat data integrity
        function validateChatData() {
            Object.keys(chats).forEach(chatId => {
                const chat = chats[chatId];
                if (!chat.id || !chat.title || !Array.isArray(chat.messages)) {
                    console.warn(`Invalid chat data for ${chatId}, removing...`);
                    delete chats[chatId];
                }
            });
        }

        // Fix 7: Handle network errors gracefully
        async function retryApiCall(apiCall, maxRetries = 3) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    await apiCall();
                    return;
                } catch (error) {
                    if (attempt === maxRetries) {
                        throw error;
                    }
                    
                    // Wait before retrying (exponential backoff)
                    const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // Fix 8: Prevent XSS in message content
        function sanitizeContent(content) {
            const div = document.createElement('div');
            div.textContent = content;
            return div.innerHTML;
        }

        // Fix 9: Handle empty or invalid responses
        function validateApiResponse(data) {
            return data && 
                   data.content && 
                   Array.isArray(data.content) && 
                   data.content.length > 0 &&
                   data.content[0].text;
        }

        // Fix 10: Memory leak prevention
        function cleanupEventListeners() {
            // Remove old event listeners when updating UI
            const oldElements = document.querySelectorAll('[data-cleanup]');
            oldElements.forEach(el => {
                el.removeEventListener('click', el._clickHandler);
                el.remove();
            });
        }

        // =============== ENHANCED FUNCTIONS ===============
        
        // Override saveToStorage with safe operation
        const originalSaveToStorage = saveToStorage;
        saveToStorage = function() {
            safeStorageOperation(() => {
                validateChatData();
                originalSaveToStorage();
            });
        };

        // Override sendMessage with enhanced error handling
        const originalSendMessage = sendMessage;
        sendMessage = async function() {
            if (!preventDuplicateMessages()) {
                return;
            }
            
            try {
                await originalSendMessage();
            } catch (error) {
                console.error('Send message error:', error);
                isProcessing = false;
                processingChatId = null;
                removeLoadingMessage();
                updateUI();
            }
        };

        // Override sendToClaudeAPI with retry logic
        const originalSendToClaudeAPI = sendToClaudeAPI;
        sendToClaudeAPI = async function() {
            await retryApiCall(async () => {
                await originalSendToClaudeAPI();
            });
        };

        // Override updateUI with debouncing and race condition prevention
        const originalUpdateUI = updateUI;
        updateUI = function() {
            originalUpdateUI();
            preventRaceCondition();
            cleanupEventListeners();
        };

        // Initialize with validation
        document.addEventListener('DOMContentLoaded', function() {
            loadFromStorage();
            validateChatData();
            updateUI();
            resetDailyUsageIfNeeded();
            
            // Set up periodic cleanup
            setInterval(() => {
                if (!isProcessing) {
                    validateChatData();
                    saveToStorage();
                }
            }, 60000); // Every minute
        });

        // =============== INITIAL STATE ===============
        if (Object.keys(chats).length === 0) {
            showWelcomeScreen();
        } else {
            // If there are existing chats, show the most recent one
            const mostRecentChat = Object.values(chats).sort((a, b) => b.createdAt - a.createdAt)[0];
            if (mostRecentChat) {
                currentChatId = mostRecentChat.id;
                showChatInterface();
                // Set model selector to match chat's model
                if (mostRecentChat.model) {
                    document.getElementById('modelSelect').value = mostRecentChat.model;
                }
            }
        }
